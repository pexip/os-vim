commit 0c8485f0e4931463c0f7986e1ea84a7d79f10c75
Author: Bram Moolenaar <Bram@vim.org>
Date:   Sun Feb 26 18:17:10 2017 +0100

    patch 8.0.0378: possible overflow when reading corrupted undo file
    
    Problem:    Another possible overflow when reading corrupted undo file.
    Solution:   Check if allocated size is not too big. (King)

diff --git a/src/undo.c b/src/undo.c
index ba7c0b83c..5b953795e 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -1423,7 +1423,7 @@ unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)
 {
     int		i;
     u_entry_T	*uep;
-    char_u	**array;
+    char_u	**array = NULL;
     char_u	*line;
     int		line_len;
 
@@ -1440,7 +1440,8 @@ unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)
     uep->ue_size = undo_read_4c(bi);
     if (uep->ue_size > 0)
     {
-	array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);
+	if (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))
+	    array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);
 	if (array == NULL)
 	{
 	    *error = TRUE;
@@ -1448,8 +1449,6 @@ unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)
 	}
 	vim_memset(array, 0, sizeof(char_u *) * uep->ue_size);
     }
-    else
-	array = NULL;
     uep->ue_array = array;
 
     for (i = 0; i < uep->ue_size; ++i)
diff --git a/src/version.c b/src/version.c
index c79020b21..026b82981 100644
--- a/src/version.c
+++ b/src/version.c
@@ -1733,6 +1733,8 @@ static char *(features[]) =
 static char *(extra_patches[]) =
 {   /* Add your patch description below this line */
 /**/
+    "8.0.0378",
+/**/
     "8.0.0377",
 /**/
     "8.0.0322",
